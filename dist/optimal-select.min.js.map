{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///optimal-select.min.js","webpack:///webpack/bootstrap 6d47700423b794420e0d","webpack:///./src/index.js","webpack:///./src/adapt.js","webpack:///./src/optimize.js","webpack:///./src/match.js","webpack:///./src/select.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","optimize","select","undefined","_select2","_select3","_optimize2","_optimize3","global","_toArray","arr","Array","isArray","from","adapt","element","options","document","context","parent","ElementPrototype","getPrototypeOf","getOwnPropertyDescriptor","enumerable","get","children","filter","node","type","attribs","attributesNames","keys","NamedNodeMap","reduce","attributes","attributeName","index","name","configurable","length","getAttribute","getElementsByTagName","tagName","HTMLCollection","traverseDescendants","childTags","descendant","push","getElementsByClassName","className","names","trim","replace","split","descendantClassName","class","every","indexOf","querySelectorAll","selectors","_this","_getInstructions","getInstructions","_getInstructions2","discover","ascendings","slice","total","step","contains","inclusive","done","reverse","map","selector","_selector$split","_selector$split2","_slicedToArray","pseudo","validate","instruction","test","substr","nodeClassName","join","getAncestor","_type$replace$split","_type$replace$split2","attributeKey","attributeValue","hasAttribute","NodeList","rule","match","kind","parseInt","validatePseudo","compareSet","nodeIndex","findIndex","child","matchedNode","nodes","handler","forEach","progress","sliceIterator","i","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","err","TypeError","arguments","globalModified","_adapt2","path","shortened","pop","current","prePart","postPart","pattern","matches","unshift","optimizePart","key","references","l","description","toLowerCase","sort","curr","partial","shift","_adapt","scoreAttribute","attribute","_options$root","_options$skip","skip","_options$ignore","ignore","skipCompare","entry","skipChecks","some","compare","ignoreClass","predicate","toString","RegExp","bind","ignoreAttribute","defaultPredicate","checkId","checkAttributeGlobal","checkClassGlobal","checkTagGlobal","checkAttributeLocal","checkClassLocal","checkTagLocal","childSelector","checkClassChild","checkAttributeChild","checkTagChild","elementSelector","parentNode","checkClass","checkIgnore","checkChild","checkAttribute","key1","key2","attributeName1","attributeName2","defaultIgnore","checkTag","tag","check","getQuerySelector","input","getMultiSelector","getSingleSelector","nodeType","Error","_typeof","_match2","optimized","elements","commonParentNode","commonClassName","commonAttribute","commonTagName","console","log","longer","shorter","classNames","constructor","prototype","_match","_optimize"],"mappings":"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","file":"optimal-select.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OptimalSelect\"] = factory();\n\telse\n\t\troot[\"OptimalSelect\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OptimalSelect\"] = factory();\n\telse\n\t\troot[\"OptimalSelect\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = exports.optimize = exports.select = undefined;\n\t\n\tvar _select2 = __webpack_require__(4);\n\t\n\tvar _select3 = _interopRequireDefault(_select2);\n\t\n\tvar _optimize2 = __webpack_require__(2);\n\t\n\tvar _optimize3 = _interopRequireDefault(_optimize2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.select = _select3.default;\n\texports.optimize = _optimize3.default;\n\texports.default = _select3.default;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = adapt;\n\t\n\tfunction _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\t\n\t/**\n\t * # Universal\n\t *\n\t * Check and extend the environment for universal usage\n\t */\n\t\n\t/**\n\t * [adapt description]\n\t * @param  {[type]} element [description]\n\t * @param  {[type]} options [description]\n\t * @return {[type]}         [description]\n\t */\n\tfunction adapt(element, options) {\n\t\n\t  // detect environment setup\n\t  if (global.document) {\n\t    return false;\n\t  }\n\t\n\t  var context = options.context;\n\t\n\t\n\t  global.document = context || function () {\n\t    var root = element;\n\t    while (root.parent) {\n\t      root = root.parent;\n\t    }\n\t    return root;\n\t  }();\n\t\n\t  // https://github.com/fb55/domhandler/blob/master/index.js#L75\n\t  var ElementPrototype = Object.getPrototypeOf(global.document);\n\t\n\t  // alternative descriptor to access elements with filtering invalid elements (e.g. textnodes)\n\t  if (!Object.getOwnPropertyDescriptor(ElementPrototype, 'childTags')) {\n\t    Object.defineProperty(ElementPrototype, 'childTags', {\n\t      enumerable: true,\n\t      get: function get() {\n\t        return this.children.filter(function (node) {\n\t          // https://github.com/fb55/domelementtype/blob/master/index.js#L12\n\t          return node.type === 'tag' || node.type === 'script' || node.type === 'style';\n\t        });\n\t      }\n\t    });\n\t  }\n\t\n\t  if (!Object.getOwnPropertyDescriptor(ElementPrototype, 'attributes')) {\n\t    // https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes\n\t    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap\n\t    Object.defineProperty(ElementPrototype, 'attributes', {\n\t      enumerable: true,\n\t      get: function get() {\n\t        var attribs = this.attribs;\n\t\n\t        var attributesNames = Object.keys(attribs);\n\t        var NamedNodeMap = attributesNames.reduce(function (attributes, attributeName, index) {\n\t          attributes[index] = {\n\t            name: attributeName,\n\t            value: attribs[attributeName]\n\t          };\n\t          return attributes;\n\t        }, {});\n\t        Object.defineProperty(NamedNodeMap, 'length', {\n\t          enumerable: false,\n\t          configurable: false,\n\t          value: attributesNames.length\n\t        });\n\t        return NamedNodeMap;\n\t      }\n\t    });\n\t  }\n\t\n\t  if (!ElementPrototype.getAttribute) {\n\t    // https://docs.webplatform.org/wiki/dom/Element/getAttribute\n\t    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute\n\t    ElementPrototype.getAttribute = function (name) {\n\t      return this.attribs[name] || null;\n\t    };\n\t  }\n\t\n\t  if (!ElementPrototype.getElementsByTagName) {\n\t    // https://docs.webplatform.org/wiki/dom/Document/getElementsByTagName\n\t    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName\n\t    ElementPrototype.getElementsByTagName = function (tagName) {\n\t      var HTMLCollection = [];\n\t      traverseDescendants(this.childTags, function (descendant) {\n\t        if (descendant.name === tagName || tagName === '*') {\n\t          HTMLCollection.push(descendant);\n\t        }\n\t      });\n\t      return HTMLCollection;\n\t    };\n\t  }\n\t\n\t  if (!ElementPrototype.getElementsByClassName) {\n\t    // https://docs.webplatform.org/wiki/dom/Document/getElementsByClassName\n\t    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName\n\t    ElementPrototype.getElementsByClassName = function (className) {\n\t      var names = className.trim().replace(/\\s+/g, ' ').split(' ');\n\t      var HTMLCollection = [];\n\t      traverseDescendants([this], function (descendant) {\n\t        var descendantClassName = descendant.attribs.class;\n\t        if (descendantClassName && names.every(function (name) {\n\t          return descendantClassName.indexOf(name) > -1;\n\t        })) {\n\t          HTMLCollection.push(descendant);\n\t        }\n\t      });\n\t      return HTMLCollection;\n\t    };\n\t  }\n\t\n\t  if (!ElementPrototype.querySelectorAll) {\n\t    // https://docs.webplatform.org/wiki/css/selectors_api/querySelectorAll\n\t    // https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll\n\t    ElementPrototype.querySelectorAll = function (selectors) {\n\t      var _this = this;\n\t\n\t      selectors = selectors.replace(/(>)(\\S)/g, '$1 $2').trim(); // add space for '>' selector\n\t\n\t      // using right to left execution => https://github.com/fb55/css-select#how-does-it-work\n\t\n\t      var _getInstructions = getInstructions(selectors),\n\t          _getInstructions2 = _toArray(_getInstructions),\n\t          discover = _getInstructions2[0],\n\t          ascendings = _getInstructions2.slice(1);\n\t\n\t      var total = ascendings.length;\n\t      return discover(this).filter(function (node) {\n\t        var step = 0;\n\t        while (step < total) {\n\t          node = ascendings[step](node, _this);\n\t          if (!node) {\n\t            // hierarchy doesn't match\n\t            return false;\n\t          }\n\t          step += 1;\n\t        }\n\t        return true;\n\t      });\n\t    };\n\t  }\n\t\n\t  if (!ElementPrototype.contains) {\n\t    // https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\n\t    ElementPrototype.contains = function (element) {\n\t      var inclusive = false;\n\t      traverseDescendants([this], function (descendant, done) {\n\t        if (descendant === element) {\n\t          inclusive = true;\n\t          done();\n\t        }\n\t      });\n\t      return inclusive;\n\t    };\n\t  }\n\t\n\t  return true;\n\t}\n\t\n\t/**\n\t * [getInstructions description]\n\t * @param  {[type]} selectors [description]\n\t * @return {[type]}           [description]\n\t */\n\tfunction getInstructions(selectors) {\n\t  return selectors.split(' ').reverse().map(function (selector, step) {\n\t    var discover = step === 0;\n\t\n\t    var _selector$split = selector.split(':'),\n\t        _selector$split2 = _slicedToArray(_selector$split, 2),\n\t        type = _selector$split2[0],\n\t        pseudo = _selector$split2[1];\n\t\n\t    var validate = null;\n\t    var instruction = null;\n\t\n\t    switch (true) {\n\t\n\t      // child: '>'\n\t      case />/.test(type):\n\t        instruction = function checkParent(node) {\n\t          return function (validate) {\n\t            return validate(node.parent) && node.parent;\n\t          };\n\t        };\n\t        break;\n\t\n\t      // class: '.'\n\t      case /^\\./.test(type):\n\t        var names = type.substr(1).split('.');\n\t        validate = function validate(node) {\n\t          var nodeClassName = node.attribs.class;\n\t          return nodeClassName && names.every(function (name) {\n\t            return nodeClassName.indexOf(name) > -1;\n\t          });\n\t        };\n\t        instruction = function checkClass(node, root) {\n\t          if (discover) {\n\t            return node.getElementsByClassName(names.join(' '));\n\t          }\n\t          return typeof node === 'function' ? node(validate) : getAncestor(node, root, validate);\n\t        };\n\t        break;\n\t\n\t      // attribute: '[key=\"value\"]'\n\t      case /^\\[/.test(type):\n\t        var _type$replace$split = type.replace(/\\[|\\]|\"/g, '').split('='),\n\t            _type$replace$split2 = _slicedToArray(_type$replace$split, 2),\n\t            attributeKey = _type$replace$split2[0],\n\t            attributeValue = _type$replace$split2[1];\n\t\n\t        validate = function validate(node) {\n\t          var hasAttribute = Object.keys(node.attribs).indexOf(attributeKey) > -1;\n\t          if (hasAttribute) {\n\t            // regard optional attributeValue\n\t            if (!attributeValue || node.attribs[attributeKey] === attributeValue) {\n\t              return true;\n\t            }\n\t          }\n\t          return false;\n\t        };\n\t        instruction = function checkAttribute(node, root) {\n\t          if (discover) {\n\t            var NodeList = [];\n\t            traverseDescendants([node], function (descendant) {\n\t              if (validate(descendant)) {\n\t                NodeList.push(descendant);\n\t              }\n\t            });\n\t            return NodeList;\n\t          }\n\t          return typeof node === 'function' ? node(validate) : getAncestor(node, root, validate);\n\t        };\n\t        break;\n\t\n\t      // id: '#'\n\t      case /^#/.test(type):\n\t        var id = type.substr(1);\n\t        validate = function validate(node) {\n\t          return node.attribs.id === id;\n\t        };\n\t        instruction = function checkId(node, root) {\n\t          if (discover) {\n\t            var NodeList = [];\n\t            traverseDescendants([node], function (descendant, done) {\n\t              if (validate(descendant)) {\n\t                NodeList.push(descendant);\n\t                done();\n\t              }\n\t            });\n\t            return NodeList;\n\t          }\n\t          return typeof node === 'function' ? node(validate) : getAncestor(node, root, validate);\n\t        };\n\t        break;\n\t\n\t      // universal: '*'\n\t      case /\\*/.test(type):\n\t        validate = function validate(node) {\n\t          return true;\n\t        };\n\t        instruction = function checkUniversal(node, root) {\n\t          if (discover) {\n\t            var NodeList = [];\n\t            traverseDescendants([node], function (descendant) {\n\t              return NodeList.push(descendant);\n\t            });\n\t            return NodeList;\n\t          }\n\t          return typeof node === 'function' ? node(validate) : getAncestor(node, root, validate);\n\t        };\n\t        break;\n\t\n\t      // tag: '...'\n\t      default:\n\t        validate = function validate(node) {\n\t          return node.name === type;\n\t        };\n\t        instruction = function checkTag(node, root) {\n\t          if (discover) {\n\t            var NodeList = [];\n\t            traverseDescendants([node], function (descendant) {\n\t              if (validate(descendant)) {\n\t                NodeList.push(descendant);\n\t              }\n\t            });\n\t            return NodeList;\n\t          }\n\t          return typeof node === 'function' ? node(validate) : getAncestor(node, root, validate);\n\t        };\n\t    }\n\t\n\t    if (!pseudo) {\n\t      return instruction;\n\t    }\n\t\n\t    var rule = pseudo.match(/-(child|type)\\((\\d+)\\)$/);\n\t    var kind = rule[1];\n\t    var index = parseInt(rule[2], 10) - 1;\n\t\n\t    var validatePseudo = function validatePseudo(node) {\n\t      if (node) {\n\t        var compareSet = node.parent.childTags;\n\t        if (kind === 'type') {\n\t          compareSet = compareSet.filter(validate);\n\t        }\n\t        var nodeIndex = compareSet.findIndex(function (child) {\n\t          return child === node;\n\t        });\n\t        if (nodeIndex === index) {\n\t          return true;\n\t        }\n\t      }\n\t      return false;\n\t    };\n\t\n\t    return function enhanceInstruction(node) {\n\t      var match = instruction(node);\n\t      if (discover) {\n\t        return match.reduce(function (NodeList, matchedNode) {\n\t          if (validatePseudo(matchedNode)) {\n\t            NodeList.push(matchedNode);\n\t          }\n\t          return NodeList;\n\t        }, []);\n\t      }\n\t      return validatePseudo(match) && match;\n\t    };\n\t  });\n\t}\n\t\n\t/**\n\t * Recursive walki\n\t * @param  {[type]} nodes   [description]\n\t * @param  {[type]} handler [description]\n\t * @return {[type]}         [description]\n\t */\n\tfunction traverseDescendants(nodes, handler) {\n\t  nodes.forEach(function (node) {\n\t    var progress = true;\n\t    handler(node, function () {\n\t      return progress = false;\n\t    });\n\t    if (node.childTags && progress) {\n\t      traverseDescendants(node.childTags, handler);\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * [getAncestor description]\n\t * @param  {[type]} node     [description]\n\t * @param  {[type]} root     [description]\n\t * @param  {[type]} validate [description]\n\t * @return {[type]}          [description]\n\t */\n\tfunction getAncestor(node, root, validate) {\n\t  while (node.parent) {\n\t    node = node.parent;\n\t    if (validate(node)) {\n\t      return node;\n\t    }\n\t    if (node === root) {\n\t      break;\n\t    }\n\t  }\n\t  return null;\n\t}\n\tmodule.exports = exports['default'];\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = optimize;\n\t\n\tvar _adapt = __webpack_require__(1);\n\t\n\tvar _adapt2 = _interopRequireDefault(_adapt);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Apply different optimization techniques\n\t * @param  {string}      selector - [description]\n\t * @param  {HTMLElement} element  - [description]\n\t * @return {string}               - [description]\n\t */\n\tfunction optimize(selector, element) {\n\t  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t\n\t  var globalModified = (0, _adapt2.default)(element, options);\n\t\n\t  // chunk parts outside of quotes (http://stackoverflow.com/a/25663729)\n\t  var path = selector.replace(/> /g, '>').split(/\\s+(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/);\n\t\n\t  if (path.length < 3) {\n\t    return selector;\n\t  }\n\t\n\t  var shortened = [path.pop()];\n\t  while (path.length > 1) {\n\t    var current = path.pop();\n\t    var prePart = path.join(' ');\n\t    var postPart = shortened.join(' ');\n\t\n\t    var pattern = prePart + ' ' + postPart;\n\t    var matches = document.querySelectorAll(pattern);\n\t    if (matches.length !== 1) {\n\t      shortened.unshift(optimizePart(prePart, current, postPart, element));\n\t    }\n\t  }\n\t  shortened.unshift(path[0]);\n\t  path = shortened;\n\t\n\t  // optimize start + end\n\t  path[0] = optimizePart('', path[0], path.slice(1).join(' '), element);\n\t  path[path.length - 1] = optimizePart(path.slice(0, -1).join(' '), path[path.length - 1], '', element);\n\t\n\t  if (globalModified) {\n\t    delete global.document;\n\t  }\n\t\n\t  return path.join(' ').replace(/>/g, '> ').trim();\n\t}\n\t\n\t/**\n\t * Improve a chunk of the selector\n\t * @param  {string}      prePart  - [description]\n\t * @param  {string}      current  - [description]\n\t * @param  {string}      postPart - [description]\n\t * @param  {HTMLElement} element  - [description]\n\t * @return {string}               - [description]\n\t */\n\t/**\n\t * # Optimize\n\t *\n\t * 1.) Improve efficiency through shorter selectors by removing redundancy\n\t * 2.) Improve robustness through selector transformation\n\t */\n\t\n\tfunction optimizePart(prePart, current, postPart, element) {\n\t  if (prePart.length) prePart = prePart + ' ';\n\t  if (postPart.length) postPart = ' ' + postPart;\n\t\n\t  // robustness: attribute without value (generalization)\n\t  if (/\\[*\\]/.test(current)) {\n\t    var key = current.replace(/=.*$/, ']');\n\t    var pattern = '' + prePart + key + postPart;\n\t    var matches = document.querySelectorAll(pattern);\n\t    if (matches.length === 1 && matches[0] === element) {\n\t      current = key;\n\t    } else {\n\t      // robustness: replace specific key-value with tag (heuristic)\n\t      var references = document.querySelectorAll('' + prePart + key);\n\t      for (var i = 0, l = references.length; i < l; i++) {\n\t        if (references[i].contains(element)) {\n\t          var description = references[i].tagName.toLowerCase();\n\t          var pattern = '' + prePart + description + postPart;\n\t          var matches = document.querySelectorAll(pattern);\n\t          if (matches.length === 1 && matches[0] === element) {\n\t            current = description;\n\t          }\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // robustness: descendant instead child (heuristic)\n\t  if (/>/.test(current)) {\n\t    var descendant = current.replace(/>/, '');\n\t    var pattern = '' + prePart + descendant + postPart;\n\t    var matches = document.querySelectorAll(pattern);\n\t    if (matches.length === 1 && matches[0] === element) {\n\t      current = descendant;\n\t    }\n\t  }\n\t\n\t  // robustness: 'nth-of-type' instead 'nth-child' (heuristic)\n\t  if (/:nth-child/.test(current)) {\n\t    // TODO: consider complete coverage of 'nth-of-type' replacement\n\t    var type = current.replace(/nth-child/g, 'nth-of-type');\n\t    var pattern = '' + prePart + type + postPart;\n\t    var matches = document.querySelectorAll(pattern);\n\t    if (matches.length === 1 && matches[0] === element) {\n\t      current = type;\n\t    }\n\t  }\n\t\n\t  // efficiency: combinations of classname (partial permutations)\n\t  if (/\\.\\S+\\.\\S+/.test(current)) {\n\t    var names = current.trim().split('.').slice(1).map(function (name) {\n\t      return '.' + name;\n\t    }).sort(function (curr, next) {\n\t      return curr.length - next.length;\n\t    });\n\t    while (names.length) {\n\t      var partial = current.replace(names.shift(), '');\n\t      var pattern = '' + prePart + partial + postPart;\n\t      var matches = document.querySelectorAll(pattern);\n\t      if (matches.length === 1 && matches[0] === element) {\n\t        current = partial;\n\t      }\n\t    }\n\t    // robustness: degrade complex classname (heuristic)\n\t    if (current && current.match(/\\./g).length > 2) {\n\t      var _references = document.querySelectorAll('' + prePart + current);\n\t      for (var i = 0, l = _references.length; i < l; i++) {\n\t        if (_references[i].contains(element)) {\n\t          // TODO:\n\t          // - check using attributes + regard excludes\n\t          var _description = _references[i].tagName.toLowerCase();\n\t          var pattern = '' + prePart + _description + postPart;\n\t          var matches = document.querySelectorAll(pattern);\n\t          if (matches.length === 1 && matches[0] === element) {\n\t            current = _description;\n\t          }\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  return current;\n\t}\n\tmodule.exports = exports['default'];\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = match;\n\t/**\n\t * # Match\n\t *\n\t * Retrieves selector\n\t */\n\t\n\tvar defaultIgnore = {\n\t  attribute: function attribute(attributeName) {\n\t    return ['style', 'data-reactid', 'data-react-checksum'].indexOf(attributeName) > -1;\n\t  }\n\t};\n\t\n\t/**\n\t *\n\t * Score attributes by their \"robustness\", so that auto-generated selectors prioritize less finicky attributes. Attributes with lower\n\t * scores are prioritized above attributes wit higher scores.\n\t */\n\tfunction scoreAttribute(attribute) {\n\t  if (attribute.indexOf('data-') === 0) return -1;\n\t  if (attribute === 'aria-label') return -1;\n\t  if (attribute === 'href') return 1;\n\t  if (attribute === 'src') return 2;\n\t  if (attribute === 'alt' || attribute === 'title') return 3;\n\t  return 0;\n\t}\n\t\n\t/**\n\t * Get the path of the element\n\t * @param  {HTMLElement} node    - [description]\n\t * @param  {Object}      options - [description]\n\t * @return {String}              - [description]\n\t */\n\tfunction match(node, options) {\n\t  var path = [];\n\t  var element = node;\n\t  var length = path.length;\n\t\n\t  var _options$root = options.root,\n\t      root = _options$root === undefined ? document : _options$root,\n\t      _options$skip = options.skip,\n\t      skip = _options$skip === undefined ? null : _options$skip,\n\t      _options$ignore = options.ignore,\n\t      ignore = _options$ignore === undefined ? {} : _options$ignore;\n\t\n\t\n\t  var skipCompare = skip && (Array.isArray(skip) ? skip : [skip]).map(function (entry) {\n\t    if (typeof entry !== 'function') {\n\t      return function (element) {\n\t        return element === entry;\n\t      };\n\t    }\n\t    return entry;\n\t  });\n\t\n\t  var skipChecks = function skipChecks(element) {\n\t    return skip && skipCompare.some(function (compare) {\n\t      return compare(element);\n\t    });\n\t  };\n\t\n\t  var ignoreClass = false;\n\t\n\t  Object.keys(ignore).forEach(function (type) {\n\t    if (type === 'class') {\n\t      ignoreClass = true;\n\t    }\n\t    var predicate = ignore[type];\n\t    if (typeof predicate === 'boolean') return;\n\t    if (typeof predicate === 'function') return;\n\t    if (typeof predicate === 'number') {\n\t      predicate = predicate.toString();\n\t    }\n\t    if (typeof predicate === 'string') {\n\t      predicate = new RegExp(predicate);\n\t    }\n\t    // check class-/attributename for regex\n\t    ignore[type] = predicate.test.bind(predicate);\n\t  });\n\t\n\t  if (ignoreClass) {\n\t    var ignoreAttribute = ignore.attribute;\n\t    ignore.attribute = function (name, value, defaultPredicate) {\n\t      return ignore.class(value) || ignoreAttribute && ignoreAttribute(name, value, defaultPredicate);\n\t    };\n\t  }\n\t\n\t  while (element !== root) {\n\t\n\t    if (skipChecks(element) !== true) {\n\t      // global\n\t      if (checkId(element, path, ignore)) break;\n\t      if (checkAttributeGlobal(element, path, ignore, root)) break;\n\t      if (checkClassGlobal(element, path, ignore, root)) break;\n\t      if (checkTagGlobal(element, path, ignore, root)) break;\n\t\n\t      // local\n\t      checkAttributeLocal(element, path, ignore);\n\t\n\t      // define only one selector each iteration\n\t      if (path.length === length) {\n\t        checkClassLocal(element, path, ignore);\n\t      }\n\t      if (path.length === length) {\n\t        checkTagLocal(element, path, ignore);\n\t      }\n\t\n\t      if (ignore.childSelector !== true) {\n\t        if (path.length === length) {\n\t          checkClassChild(element, path, ignore);\n\t        }\n\t        if (path.length === length) {\n\t          checkAttributeChild(element, path, ignore);\n\t        }\n\t        if (path.length === length) {\n\t          checkTagChild(element, path, ignore);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (element === node && path.length === 0) {\n\t      var elementSelector = element.tagName.toLowerCase();\n\t      var className = element.getAttribute('class');\n\t      if (className) {\n\t        elementSelector += '.' + className.trim().replace(/\\s+/g, '.');\n\t      }\n\t      path.unshift(elementSelector);\n\t    }\n\t\n\t    element = element.parentNode;\n\t    length = path.length;\n\t  }\n\t\n\t  return path.join(' ');\n\t}\n\t\n\t/**\n\t * [checkClassGlobal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkClassGlobal(element, path, ignore, root) {\n\t  return checkClass(element, path, ignore, root);\n\t}\n\t\n\t/**\n\t * [checkClassLocal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkClassLocal(element, path, ignore) {\n\t  return checkClass(element, path, ignore, element.parentNode);\n\t}\n\t\n\t/**\n\t * [checkClassChild description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkClassChild(element, path, ignore) {\n\t  var className = element.getAttribute('class');\n\t  if (checkIgnore(ignore.class, className)) {\n\t    return false;\n\t  }\n\t  return checkChild(element, path, '.' + className.trim().replace(/\\s+/g, '.'));\n\t}\n\t\n\t/**\n\t * [checkAttributeGlobal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkAttributeGlobal(element, path, ignore, root) {\n\t  return checkAttribute(element, path, ignore, root);\n\t}\n\t\n\t/**\n\t * [checkAttributeLocal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkAttributeLocal(element, path, ignore) {\n\t  return checkAttribute(element, path, ignore, element.parentNode);\n\t}\n\t\n\t/**\n\t * [checkAttributeChild description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkAttributeChild(element, path, ignore) {\n\t  var attributes = element.attributes;\n\t  return Object.keys(attributes).sort(function (key1, key2) {\n\t    var attributeName1 = attributes[key1].name;\n\t    var attributeName2 = attributes[key2].name;\n\t    return scoreAttribute(attributeName1) - scoreAttribute(attributeName2);\n\t  }).some(function (key) {\n\t    var attribute = attributes[key];\n\t    var attributeName = attribute.name;\n\t    // FIXME: Downstream hierarchy parsing is broken. For now, just omit double-quotes.\n\t    var attributeValue = attribute.value.replace(/\"/g, '');\n\t    if (checkIgnore(ignore.attribute, attributeName, attributeValue, defaultIgnore.attribute)) {\n\t      return false;\n\t    }\n\t    var pattern = '[' + attributeName + '=\"' + attributeValue + '\"]';\n\t    return checkChild(element, path, pattern);\n\t  });\n\t}\n\t\n\t/**\n\t * [checkTagGlobal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkTagGlobal(element, path, ignore, root) {\n\t  return checkTag(element, path, ignore, root);\n\t}\n\t\n\t/**\n\t * [checkTagLocal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkTagLocal(element, path, ignore) {\n\t  return checkTag(element, path, ignore, element.parentNode);\n\t}\n\t\n\t/**\n\t * [checkTabChildren description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkTagChild(element, path, ignore) {\n\t  var tagName = element.tagName.toLowerCase();\n\t  if (checkIgnore(ignore.tag, tagName)) {\n\t    return false;\n\t  }\n\t  return checkChild(element, path, tagName);\n\t}\n\t\n\t/**\n\t * [checkId description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkId(element, path, ignore) {\n\t  var id = element.getAttribute('id');\n\t  if (checkIgnore(ignore.id, id)) {\n\t    return false;\n\t  }\n\t  path.unshift('#' + id);\n\t  return true;\n\t}\n\t\n\t/**\n\t * [checkClass description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @param  {HTMLElement} parent  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkClass(element, path, ignore, parent) {\n\t  var className = element.getAttribute('class');\n\t  if (checkIgnore(ignore.class, className)) {\n\t    return false;\n\t  }\n\t  var matches = parent.getElementsByClassName(className);\n\t  if (matches.length === 1) {\n\t    path.unshift('.' + className.trim().replace(/\\s+/g, '.'));\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * [checkAttribute description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @param  {HTMLElement} parent  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkAttribute(element, path, ignore, parent) {\n\t  var attributes = element.attributes;\n\t  return Object.keys(attributes).sort(function (key1, key2) {\n\t    var attributeName1 = attributes[key1].name;\n\t    var attributeName2 = attributes[key2].name;\n\t    return scoreAttribute(attributeName1) - scoreAttribute(attributeName2);\n\t  }).some(function (key) {\n\t    var attribute = attributes[key];\n\t    var attributeName = attribute.name;\n\t    // FIXME: Downstream hierarchy parsing is broken. For now, just omit double-quotes.\n\t    var attributeValue = attribute.value.replace(/\"/g, '');\n\t    if (checkIgnore(ignore.attribute, attributeName, attributeValue, defaultIgnore.attribute)) {\n\t      return false;\n\t    }\n\t    var pattern = '[' + attributeName + '=\"' + attributeValue + '\"]';\n\t    var matches = parent.querySelectorAll(pattern);\n\t    if (matches.length === 1) {\n\t      path.unshift(pattern);\n\t      return true;\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * [checkTag description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {HTMLElement} parent  - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkTag(element, path, ignore, parent) {\n\t  var tagName = element.tagName.toLowerCase();\n\t  if (checkIgnore(ignore.tag, tagName)) {\n\t    return false;\n\t  }\n\t  var matches = parent.getElementsByTagName(tagName);\n\t  if (matches.length === 1) {\n\t    path.unshift(tagName);\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * [checkChild description]\n\t * Note: childTags is a custom property to use a view filter for tags on for virutal elements\n\t * @param  {HTMLElement} element  - [description]\n\t * @param  {Array}       path     - [description]\n\t * @param  {String}      selector - [description]\n\t * @return {Boolean}              - [description]\n\t */\n\tfunction checkChild(element, path, selector) {\n\t  var parent = element.parentNode;\n\t  var children = parent.childTags || parent.children;\n\t  for (var i = 0, l = children.length; i < l; i++) {\n\t    if (children[i] === element) {\n\t      path.unshift('> ' + selector + ':nth-child(' + (i + 1) + ')');\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * [checkIgnore description]\n\t * @param  {Function} predicate        [description]\n\t * @param  {string}   name             [description]\n\t * @param  {string}   value            [description]\n\t * @param  {Function} defaultPredicate [description]\n\t * @return {boolean}                   [description]\n\t */\n\tfunction checkIgnore(predicate, name, value, defaultPredicate) {\n\t  if (!name) {\n\t    return true;\n\t  }\n\t  var check = predicate || defaultPredicate;\n\t  if (!check) {\n\t    return false;\n\t  }\n\t  return check(name, value || name, defaultPredicate);\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /**\n\t                                                                                                                                                                                                                                                                               * # Select\n\t                                                                                                                                                                                                                                                                               *\n\t                                                                                                                                                                                                                                                                               * Construct a unique CSS queryselector to access the selected DOM element(s).\n\t                                                                                                                                                                                                                                                                               * Applies different matching and optimization strategies for efficiency.\n\t                                                                                                                                                                                                                                                                               */\n\t\n\texports.default = getQuerySelector;\n\texports.getSingleSelector = getSingleSelector;\n\texports.getMultiSelector = getMultiSelector;\n\t\n\tvar _adapt = __webpack_require__(1);\n\t\n\tvar _adapt2 = _interopRequireDefault(_adapt);\n\t\n\tvar _match = __webpack_require__(3);\n\t\n\tvar _match2 = _interopRequireDefault(_match);\n\t\n\tvar _optimize = __webpack_require__(2);\n\t\n\tvar _optimize2 = _interopRequireDefault(_optimize);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Choose action depending on the input (single/multi)\n\t * @param  {HTMLElement|Array} input   - [description]\n\t * @param  {Object}            options - [description]\n\t * @return {string}                    - [description]\n\t */\n\tfunction getQuerySelector(input) {\n\t  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  if (Array.isArray(input)) {\n\t    return getMultiSelector(input, options);\n\t  }\n\t  return getSingleSelector(input, options);\n\t}\n\t\n\t/**\n\t * Get a selector for the provided element\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Object}      options - [description]\n\t * @return {String}              - [description]\n\t */\n\tfunction getSingleSelector(element, options) {\n\t\n\t  if (element.nodeType === 3) {\n\t    return getSingleSelector(element.parentNode);\n\t  }\n\t  if (element.nodeType !== 1) {\n\t    throw new Error('Invalid input - only HTMLElements or representations of them are supported! (not \"' + (typeof element === 'undefined' ? 'undefined' : _typeof(element)) + '\")');\n\t  }\n\t\n\t  var globalModified = (0, _adapt2.default)(element, options);\n\t\n\t  var selector = (0, _match2.default)(element, options);\n\t  var optimized = (0, _optimize2.default)(selector, element, options);\n\t\n\t  // debug\n\t  // console.log(`\n\t  //   selector: ${selector}\n\t  //   optimized:${optimized}\n\t  // `)\n\t\n\t  if (globalModified) {\n\t    delete global.document;\n\t  }\n\t\n\t  return optimized;\n\t}\n\t\n\t/**\n\t * Get a selector to match multiple children from a parent\n\t * @param  {Array}  elements - [description]\n\t * @param  {Object} options  - [description]\n\t * @return {string}          - [description]\n\t */\n\tfunction getMultiSelector(elements, options) {\n\t  var commonParentNode = null;\n\t  var commonClassName = null;\n\t  var commonAttribute = null;\n\t  var commonTagName = null;\n\t\n\t  for (var i = 0, l = elements.length; i < l; i++) {\n\t    var element = elements[i];\n\t    if (!commonParentNode) {\n\t      // 1st entry\n\t      commonParentNode = element.parentNode;\n\t      commonClassName = element.className;\n\t      // commonAttribute = element.attributes\n\t      commonTagName = element.tagName;\n\t    } else if (commonParentNode !== element.parentNode) {\n\t      return console.log('Can\\'t be efficiently mapped. It probably best to use multiple single selectors instead!');\n\t    }\n\t    if (element.className !== commonClassName) {\n\t      var classNames = [];\n\t      var longer, shorter;\n\t      if (element.className.length > commonClassName.length) {\n\t        longer = element.className;\n\t        shorter = commonClassName;\n\t      } else {\n\t        longer = commonClassName;\n\t        shorter = element.className;\n\t      }\n\t      shorter.split(' ').forEach(function (name) {\n\t        if (longer.indexOf(name) > -1) {\n\t          classNames.push(name);\n\t        }\n\t      });\n\t      commonClassName = classNames.join(' ');\n\t    }\n\t    // TODO:\n\t    // - check attributes\n\t    // if (element.attributes !== commonAttribute) {\n\t    //\n\t    // }\n\t    if (element.tagName !== commonTagName) {\n\t      commonTagName = null;\n\t    }\n\t  }\n\t\n\t  var selector = getSingleSelector(commonParentNode, options);\n\t  console.log(selector, commonClassName, commonAttribute, commonTagName);\n\t\n\t  if (commonClassName) {\n\t    return selector + ' > .' + commonClassName.replace(/ /g, '.');\n\t  }\n\t  // if (commonAttribute) {\n\t  //\n\t  // }\n\t  if (commonTagName) {\n\t    return selector + ' > ' + commonTagName.toLowerCase();\n\t  }\n\t  return selector + ' > *';\n\t}\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// optimal-select.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6d47700423b794420e0d","export select from './select'\nexport optimize from './optimize'\n\nexport default from './select'\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/**\n * # Universal\n *\n * Check and extend the environment for universal usage\n */\n\n/**\n * [adapt description]\n * @param  {[type]} element [description]\n * @param  {[type]} options [description]\n * @return {[type]}         [description]\n */\nexport default function adapt (element, options) {\n\n  // detect environment setup\n  if (global.document) {\n    return false\n  }\n\n  const { context } = options\n\n  global.document = context || (() => {\n    var root = element\n    while (root.parent) {\n      root = root.parent\n    }\n    return root\n  })()\n\n  // https://github.com/fb55/domhandler/blob/master/index.js#L75\n  const ElementPrototype = Object.getPrototypeOf(global.document)\n\n  // alternative descriptor to access elements with filtering invalid elements (e.g. textnodes)\n  if (!Object.getOwnPropertyDescriptor(ElementPrototype, 'childTags')) {\n    Object.defineProperty(ElementPrototype, 'childTags', {\n      enumerable: true,\n      get () {\n        return this.children.filter((node) => {\n          // https://github.com/fb55/domelementtype/blob/master/index.js#L12\n          return node.type === 'tag' || node.type === 'script' || node.type === 'style'\n        })\n      }\n    })\n  }\n\n  if (!Object.getOwnPropertyDescriptor(ElementPrototype, 'attributes')) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes\n    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap\n    Object.defineProperty(ElementPrototype, 'attributes', {\n      enumerable: true,\n      get () {\n        const { attribs } = this\n        const attributesNames = Object.keys(attribs)\n        const NamedNodeMap = attributesNames.reduce((attributes, attributeName, index) => {\n          attributes[index] = {\n            name: attributeName,\n            value: attribs[attributeName]\n          }\n          return attributes\n        }, { })\n        Object.defineProperty(NamedNodeMap, 'length', {\n          enumerable: false,\n          configurable: false,\n          value: attributesNames.length\n        })\n        return NamedNodeMap\n      }\n    })\n  }\n\n  if (!ElementPrototype.getAttribute) {\n    // https://docs.webplatform.org/wiki/dom/Element/getAttribute\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute\n    ElementPrototype.getAttribute = function (name) {\n      return this.attribs[name] || null\n    }\n  }\n\n  if (!ElementPrototype.getElementsByTagName) {\n    // https://docs.webplatform.org/wiki/dom/Document/getElementsByTagName\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName\n    ElementPrototype.getElementsByTagName = function (tagName) {\n      const HTMLCollection = []\n      traverseDescendants(this.childTags, (descendant) => {\n        if (descendant.name === tagName || tagName === '*') {\n          HTMLCollection.push(descendant)\n        }\n      })\n      return HTMLCollection\n    }\n  }\n\n  if (!ElementPrototype.getElementsByClassName) {\n    // https://docs.webplatform.org/wiki/dom/Document/getElementsByClassName\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName\n    ElementPrototype.getElementsByClassName = function (className) {\n      const names = className.trim().replace(/\\s+/g, ' ').split(' ')\n      const HTMLCollection = []\n      traverseDescendants([this], (descendant) => {\n        const descendantClassName = descendant.attribs.class\n        if (descendantClassName && names.every((name) => descendantClassName.indexOf(name) > -1)) {\n          HTMLCollection.push(descendant)\n        }\n      })\n      return HTMLCollection\n    }\n  }\n\n  if (!ElementPrototype.querySelectorAll) {\n    // https://docs.webplatform.org/wiki/css/selectors_api/querySelectorAll\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll\n    ElementPrototype.querySelectorAll = function (selectors) {\n      selectors = selectors.replace(/(>)(\\S)/g, '$1 $2').trim() // add space for '>' selector\n\n      // using right to left execution => https://github.com/fb55/css-select#how-does-it-work\n      const [discover, ...ascendings] = getInstructions(selectors)\n      const total = ascendings.length\n      return discover(this).filter((node) => {\n        var step = 0\n        while (step < total) {\n          node = ascendings[step](node, this)\n          if (!node) { // hierarchy doesn't match\n            return false\n          }\n          step += 1\n        }\n        return true\n      })\n    }\n  }\n\n  if (!ElementPrototype.contains) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\n    ElementPrototype.contains = function (element) {\n      var inclusive = false\n      traverseDescendants([this], (descendant, done) => {\n        if (descendant === element) {\n          inclusive = true\n          done()\n        }\n      })\n      return inclusive\n    }\n  }\n\n  return true\n}\n\n/**\n * [getInstructions description]\n * @param  {[type]} selectors [description]\n * @return {[type]}           [description]\n */\nfunction getInstructions (selectors) {\n  return selectors.split(' ').reverse().map((selector, step) => {\n    const discover = step === 0\n    const [type, pseudo] = selector.split(':')\n\n    var validate = null\n    var instruction = null\n\n    switch (true) {\n\n      // child: '>'\n      case />/.test(type):\n        instruction = function checkParent (node) {\n          return (validate) => validate(node.parent) && node.parent\n        }\n        break\n\n      // class: '.'\n      case /^\\./.test(type):\n        const names = type.substr(1).split('.')\n        validate = (node) => {\n          const nodeClassName = node.attribs.class\n          return nodeClassName && names.every((name) => nodeClassName.indexOf(name) > -1)\n        }\n        instruction = function checkClass (node, root) {\n          if (discover) {\n            return node.getElementsByClassName(names.join(' '))\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n\n      // attribute: '[key=\"value\"]'\n      case /^\\[/.test(type):\n        const [attributeKey, attributeValue] = type.replace(/\\[|\\]|\"/g, '').split('=')\n        validate = (node) => {\n          const hasAttribute = Object.keys(node.attribs).indexOf(attributeKey) > -1\n          if (hasAttribute) { // regard optional attributeValue\n            if (!attributeValue || (node.attribs[attributeKey] === attributeValue)) {\n              return true\n            }\n          }\n          return false\n        }\n        instruction = function checkAttribute (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant) => {\n              if (validate(descendant)) {\n                NodeList.push(descendant)\n              }\n            })\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n\n      // id: '#'\n      case /^#/.test(type):\n        const id = type.substr(1)\n        validate = (node) => {\n          return node.attribs.id === id\n        }\n        instruction = function checkId (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant, done) => {\n              if (validate(descendant)) {\n                NodeList.push(descendant)\n                done()\n              }\n            })\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n\n      // universal: '*'\n      case /\\*/.test(type):\n        validate = (node) => true\n        instruction = function checkUniversal (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant) => NodeList.push(descendant))\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n\n      // tag: '...'\n      default:\n        validate = (node) => {\n          return node.name === type\n        }\n        instruction = function checkTag (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant) => {\n              if (validate(descendant)) {\n                NodeList.push(descendant)\n              }\n            })\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n    }\n\n    if (!pseudo) {\n      return instruction\n    }\n\n    const rule = pseudo.match(/-(child|type)\\((\\d+)\\)$/)\n    const kind = rule[1]\n    const index = parseInt(rule[2], 10) - 1\n\n    const validatePseudo = (node) => {\n      if (node) {\n        var compareSet = node.parent.childTags\n        if (kind === 'type') {\n          compareSet = compareSet.filter(validate)\n        }\n        const nodeIndex = compareSet.findIndex((child) => child === node)\n        if (nodeIndex === index) {\n          return true\n        }\n      }\n      return false\n    }\n\n    return function enhanceInstruction (node) {\n      const match = instruction(node)\n      if (discover) {\n        return match.reduce((NodeList, matchedNode) => {\n          if (validatePseudo(matchedNode)) {\n            NodeList.push(matchedNode)\n          }\n          return NodeList\n        }, [])\n      }\n      return validatePseudo(match) && match\n    }\n  })\n}\n\n/**\n * Recursive walki\n * @param  {[type]} nodes   [description]\n * @param  {[type]} handler [description]\n * @return {[type]}         [description]\n */\nfunction traverseDescendants (nodes, handler) {\n  nodes.forEach((node) => {\n    var progress = true\n    handler(node, () => progress = false)\n    if (node.childTags && progress) {\n      traverseDescendants(node.childTags, handler)\n    }\n  })\n}\n\n/**\n * [getAncestor description]\n * @param  {[type]} node     [description]\n * @param  {[type]} root     [description]\n * @param  {[type]} validate [description]\n * @return {[type]}          [description]\n */\nfunction getAncestor (node, root, validate) {\n  while (node.parent) {\n    node = node.parent\n    if (validate(node)) {\n      return node\n    }\n    if (node === root) {\n      break\n    }\n  }\n  return null\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/adapt.js","/**\n * # Optimize\n *\n * 1.) Improve efficiency through shorter selectors by removing redundancy\n * 2.) Improve robustness through selector transformation\n */\n\nimport adapt from './adapt'\n\n/**\n * Apply different optimization techniques\n * @param  {string}      selector - [description]\n * @param  {HTMLElement} element  - [description]\n * @return {string}               - [description]\n */\nexport default function optimize (selector, element, options = {}) {\n\n  const globalModified = adapt(element, options)\n\n  // chunk parts outside of quotes (http://stackoverflow.com/a/25663729)\n  var path = selector.replace(/> /g, '>').split(/\\s+(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/)\n\n  if (path.length < 3) {\n    return selector\n  }\n\n  const shortened = [path.pop()]\n  while (path.length > 1)  {\n    const current = path.pop()\n    const prePart = path.join(' ')\n    const postPart = shortened.join(' ')\n\n    const pattern = `${prePart} ${postPart}`\n    const matches = document.querySelectorAll(pattern)\n    if (matches.length !== 1) {\n      shortened.unshift(optimizePart(prePart, current, postPart, element))\n    }\n  }\n  shortened.unshift(path[0])\n  path = shortened\n\n  // optimize start + end\n  path[0] = optimizePart('', path[0], path.slice(1).join(' '), element)\n  path[path.length-1] = optimizePart(path.slice(0, -1).join(' '), path[path.length-1], '', element)\n\n  if (globalModified) {\n    delete global.document\n  }\n\n  return path.join(' ').replace(/>/g, '> ').trim()\n}\n\n/**\n * Improve a chunk of the selector\n * @param  {string}      prePart  - [description]\n * @param  {string}      current  - [description]\n * @param  {string}      postPart - [description]\n * @param  {HTMLElement} element  - [description]\n * @return {string}               - [description]\n */\nfunction optimizePart (prePart, current, postPart, element) {\n  if (prePart.length) prePart = `${prePart} `\n  if (postPart.length) postPart = ` ${postPart}`\n\n  // robustness: attribute without value (generalization)\n  if (/\\[*\\]/.test(current)) {\n    const key = current.replace(/=.*$/, ']')\n    var pattern = `${prePart}${key}${postPart}`\n    var matches = document.querySelectorAll(pattern)\n    if (matches.length === 1 && matches[0] === element) {\n      current = key\n    } else {\n      // robustness: replace specific key-value with tag (heuristic)\n      const references = document.querySelectorAll(`${prePart}${key}`)\n      for (var i = 0, l = references.length; i < l; i++) {\n        if (references[i].contains(element)) {\n          const description = references[i].tagName.toLowerCase()\n          var pattern = `${prePart}${description}${postPart}`\n          var matches = document.querySelectorAll(pattern)\n          if (matches.length === 1 && matches[0] === element) {\n            current = description\n          }\n          break\n        }\n      }\n    }\n  }\n\n  // robustness: descendant instead child (heuristic)\n  if (/>/.test(current)) {\n    const descendant = current.replace(/>/, '')\n    var pattern = `${prePart}${descendant}${postPart}`\n    var matches = document.querySelectorAll(pattern)\n    if (matches.length === 1 && matches[0] === element) {\n      current = descendant\n    }\n  }\n\n  // robustness: 'nth-of-type' instead 'nth-child' (heuristic)\n  if (/:nth-child/.test(current)) {\n    // TODO: consider complete coverage of 'nth-of-type' replacement\n    const type = current.replace(/nth-child/g, 'nth-of-type')\n    var pattern = `${prePart}${type}${postPart}`\n    var matches = document.querySelectorAll(pattern)\n    if (matches.length === 1 && matches[0] === element) {\n      current = type\n    }\n  }\n\n  // efficiency: combinations of classname (partial permutations)\n  if (/\\.\\S+\\.\\S+/.test(current)) {\n    const names = current.trim().split('.').slice(1).map((name) => `.${name}`)\n                                .sort((curr, next) => curr.length - next.length)\n    while (names.length) {\n      var partial = current.replace(names.shift(), '')\n      var pattern = `${prePart}${partial}${postPart}`\n      var matches = document.querySelectorAll(pattern)\n      if (matches.length === 1 && matches[0] === element) {\n        current = partial\n      }\n    }\n    // robustness: degrade complex classname (heuristic)\n    if (current && current.match(/\\./g).length > 2) {\n      const references = document.querySelectorAll(`${prePart}${current}`)\n      for (var i = 0, l = references.length; i < l; i++) {\n        if (references[i].contains(element)) {\n          // TODO:\n          // - check using attributes + regard excludes\n          const description = references[i].tagName.toLowerCase()\n          var pattern = `${prePart}${description}${postPart}`\n          var matches = document.querySelectorAll(pattern)\n          if (matches.length === 1 && matches[0] === element) {\n            current = description\n          }\n          break\n        }\n      }\n    }\n  }\n\n  return current\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/optimize.js","/**\n * # Match\n *\n * Retrieves selector\n */\n\nconst defaultIgnore = {\n  attribute (attributeName) {\n    return [\n      'style',\n      'data-reactid',\n      'data-react-checksum'\n    ].indexOf(attributeName) > -1\n  }\n}\n\n/**\n *\n * Score attributes by their \"robustness\", so that auto-generated selectors prioritize less finicky attributes. Attributes with lower\n * scores are prioritized above attributes wit higher scores.\n */\nfunction scoreAttribute (attribute) {\n  if (attribute.indexOf('data-') === 0) return -1\n  if (attribute === 'aria-label') return -1\n  if (attribute === 'href') return 1\n  if (attribute === 'src') return 2\n  if (attribute === 'alt' || attribute === 'title') return 3\n  return 0\n}\n\n/**\n * Get the path of the element\n * @param  {HTMLElement} node    - [description]\n * @param  {Object}      options - [description]\n * @return {String}              - [description]\n */\nexport default function match (node, options) {\n  const path = []\n  var element = node\n  var length = path.length\n\n  const {\n    root = document,\n    skip = null,\n    ignore = {}\n  } = options\n\n  const skipCompare = skip && (Array.isArray(skip) ? skip : [skip]).map((entry) => {\n    if (typeof entry !== 'function') {\n      return (element) => element === entry\n    }\n    return entry\n  })\n\n  const skipChecks = (element) => {\n    return skip && skipCompare.some((compare) => compare(element))\n  }\n\n  var ignoreClass = false\n\n  Object.keys(ignore).forEach((type) => {\n    if (type === 'class') {\n      ignoreClass = true\n    }\n    var predicate = ignore[type]\n    if (typeof predicate === 'boolean') return\n    if (typeof predicate === 'function') return\n    if (typeof predicate === 'number') {\n      predicate = predicate.toString()\n    }\n    if (typeof predicate === 'string') {\n      predicate = new RegExp(predicate)\n    }\n    // check class-/attributename for regex\n    ignore[type] = predicate.test.bind(predicate)\n  })\n\n  if (ignoreClass) {\n    const ignoreAttribute = ignore.attribute\n    ignore.attribute = (name, value, defaultPredicate) => {\n      return ignore.class(value) || ignoreAttribute && ignoreAttribute(name, value, defaultPredicate)\n    }\n  }\n\n  while (element !== root) {\n\n    if (skipChecks(element) !== true) {\n      // global\n      if (checkId(element, path, ignore)) break\n      if (checkAttributeGlobal(element, path, ignore, root)) break\n      if (checkClassGlobal(element, path, ignore, root)) break\n      if (checkTagGlobal(element, path, ignore, root)) break\n\n      // local\n      checkAttributeLocal(element, path, ignore)\n\n      // define only one selector each iteration\n      if (path.length === length) {\n        checkClassLocal(element, path, ignore)\n      }\n      if (path.length === length) {\n        checkTagLocal(element, path, ignore)\n      }\n\n      if (ignore.childSelector !== true) {\n        if (path.length === length) {\n          checkClassChild(element, path, ignore)\n        }\n        if (path.length === length) {\n          checkAttributeChild(element, path, ignore)\n        }\n        if (path.length === length) {\n          checkTagChild(element, path, ignore)\n        }\n      }\n    }\n\n    if (element === node && path.length === 0) {\n      var elementSelector = element.tagName.toLowerCase()\n      var className = element.getAttribute('class')\n      if (className) {\n        elementSelector += `.${className.trim().replace(/\\s+/g, '.')}`\n      }\n      path.unshift(elementSelector)\n    }\n\n    element = element.parentNode\n    length = path.length\n  }\n\n  return path.join(' ')\n}\n\n\n/**\n * [checkClassGlobal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkClassGlobal (element, path, ignore, root) {\n  return checkClass(element, path, ignore, root)\n}\n\n/**\n * [checkClassLocal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkClassLocal (element, path, ignore) {\n  return checkClass(element, path, ignore, element.parentNode)\n}\n\n/**\n * [checkClassChild description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkClassChild (element, path, ignore) {\n  const className = element.getAttribute('class')\n  if (checkIgnore(ignore.class, className)) {\n    return false\n  }\n  return checkChild(element, path, `.${className.trim().replace(/\\s+/g, '.')}`)\n}\n\n/**\n * [checkAttributeGlobal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkAttributeGlobal (element, path, ignore, root) {\n  return checkAttribute(element, path, ignore, root)\n}\n\n/**\n * [checkAttributeLocal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkAttributeLocal (element, path, ignore) {\n  return checkAttribute(element, path, ignore, element.parentNode)\n}\n\n/**\n * [checkAttributeChild description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkAttributeChild (element, path, ignore) {\n  const attributes = element.attributes\n  return Object.keys(attributes)\n    .sort((key1, key2) => {\n      const attributeName1 = attributes[key1].name\n      const attributeName2 = attributes[key2].name\n      return scoreAttribute(attributeName1) - scoreAttribute(attributeName2)\n    })\n    .some((key) => {\n      const attribute = attributes[key]\n      const attributeName = attribute.name\n      // FIXME: Downstream hierarchy parsing is broken. For now, just omit double-quotes.\n      const attributeValue = attribute.value.replace(/\"/g, '')\n      if (checkIgnore(ignore.attribute, attributeName, attributeValue, defaultIgnore.attribute)) {\n        return false\n      }\n      const pattern = `[${attributeName}=\"${attributeValue}\"]`\n      return checkChild(element, path, pattern)\n    })\n}\n\n/**\n * [checkTagGlobal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkTagGlobal (element, path, ignore, root) {\n  return checkTag(element, path, ignore, root)\n}\n\n/**\n * [checkTagLocal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkTagLocal (element, path, ignore) {\n  return checkTag(element, path, ignore, element.parentNode)\n}\n\n/**\n * [checkTabChildren description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkTagChild (element, path, ignore) {\n  const tagName = element.tagName.toLowerCase()\n  if (checkIgnore(ignore.tag, tagName)) {\n    return false\n  }\n  return checkChild(element, path, tagName)\n}\n\n/**\n * [checkId description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkId (element, path, ignore) {\n  const id = element.getAttribute('id')\n  if (checkIgnore(ignore.id, id)) {\n    return false\n  }\n  path.unshift(`#${id}`)\n  return true\n}\n\n/**\n * [checkClass description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @param  {HTMLElement} parent  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkClass (element, path, ignore, parent) {\n  const className = element.getAttribute('class')\n  if (checkIgnore(ignore.class, className)) {\n    return false\n  }\n  const matches = parent.getElementsByClassName(className)\n  if (matches.length === 1) {\n    path.unshift(`.${className.trim().replace(/\\s+/g, '.')}`)\n    return true\n  }\n  return false\n}\n\n/**\n * [checkAttribute description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @param  {HTMLElement} parent  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkAttribute (element, path, ignore, parent) {\n  const attributes = element.attributes\n  return Object.keys(attributes)\n    .sort((key1, key2) => {\n      const attributeName1 = attributes[key1].name\n      const attributeName2 = attributes[key2].name\n      return scoreAttribute(attributeName1) - scoreAttribute(attributeName2)\n    })\n    .some((key) => {\n      const attribute = attributes[key]\n      const attributeName = attribute.name\n      // FIXME: Downstream hierarchy parsing is broken. For now, just omit double-quotes.\n      const attributeValue = attribute.value.replace(/\"/g, '')\n      if (checkIgnore(ignore.attribute, attributeName, attributeValue, defaultIgnore.attribute)) {\n        return false\n      }\n      const pattern = `[${attributeName}=\"${attributeValue}\"]`\n      const matches = parent.querySelectorAll(pattern)\n      if (matches.length === 1) {\n        path.unshift(pattern)\n        return true\n      }\n    })\n}\n\n/**\n * [checkTag description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {HTMLElement} parent  - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkTag (element, path, ignore, parent) {\n  const tagName = element.tagName.toLowerCase()\n  if (checkIgnore(ignore.tag, tagName)) {\n    return false\n  }\n  const matches = parent.getElementsByTagName(tagName)\n  if (matches.length === 1) {\n    path.unshift(tagName)\n    return true\n  }\n  return false\n}\n\n/**\n * [checkChild description]\n * Note: childTags is a custom property to use a view filter for tags on for virutal elements\n * @param  {HTMLElement} element  - [description]\n * @param  {Array}       path     - [description]\n * @param  {String}      selector - [description]\n * @return {Boolean}              - [description]\n */\nfunction checkChild (element, path, selector) {\n  const parent = element.parentNode\n  const children = parent.childTags || parent.children\n  for (var i = 0, l = children.length; i < l; i++) {\n    if (children[i] === element) {\n      path.unshift(`> ${selector}:nth-child(${i+1})`)\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * [checkIgnore description]\n * @param  {Function} predicate        [description]\n * @param  {string}   name             [description]\n * @param  {string}   value            [description]\n * @param  {Function} defaultPredicate [description]\n * @return {boolean}                   [description]\n */\nfunction checkIgnore (predicate, name, value, defaultPredicate) {\n  if (!name) {\n    return true\n  }\n  const check = predicate || defaultPredicate\n  if (!check) {\n    return false\n  }\n  return check(name, value || name, defaultPredicate)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/match.js","/**\n * # Select\n *\n * Construct a unique CSS queryselector to access the selected DOM element(s).\n * Applies different matching and optimization strategies for efficiency.\n */\n\nimport adapt from './adapt'\nimport match from './match'\nimport optimize from './optimize'\n\n/**\n * Choose action depending on the input (single/multi)\n * @param  {HTMLElement|Array} input   - [description]\n * @param  {Object}            options - [description]\n * @return {string}                    - [description]\n */\nexport default function getQuerySelector (input, options = {}) {\n  if (Array.isArray(input)) {\n    return getMultiSelector(input, options)\n  }\n  return getSingleSelector(input, options)\n}\n\n/**\n * Get a selector for the provided element\n * @param  {HTMLElement} element - [description]\n * @param  {Object}      options - [description]\n * @return {String}              - [description]\n */\nexport function getSingleSelector (element, options) {\n\n  if (element.nodeType === 3) {\n    return getSingleSelector(element.parentNode)\n  }\n  if (element.nodeType !== 1) {\n    throw new Error(`Invalid input - only HTMLElements or representations of them are supported! (not \"${typeof element}\")`)\n  }\n\n  const globalModified = adapt(element, options)\n\n  const selector = match(element, options)\n  const optimized = optimize(selector, element, options)\n\n  // debug\n  // console.log(`\n  //   selector: ${selector}\n  //   optimized:${optimized}\n  // `)\n\n  if (globalModified) {\n    delete global.document\n  }\n\n  return optimized\n}\n\n/**\n * Get a selector to match multiple children from a parent\n * @param  {Array}  elements - [description]\n * @param  {Object} options  - [description]\n * @return {string}          - [description]\n */\nexport function getMultiSelector (elements, options) {\n  var commonParentNode = null\n  var commonClassName = null\n  var commonAttribute = null\n  var commonTagName = null\n\n  for (var i = 0, l = elements.length; i < l; i++) {\n    var element = elements[i]\n    if (!commonParentNode) { // 1st entry\n      commonParentNode = element.parentNode\n      commonClassName = element.className\n      // commonAttribute = element.attributes\n      commonTagName = element.tagName\n    } else if (commonParentNode !== element.parentNode) {\n      return console.log('Can\\'t be efficiently mapped. It probably best to use multiple single selectors instead!')\n    }\n    if (element.className !== commonClassName) {\n      var classNames = []\n      var longer, shorter\n      if (element.className.length > commonClassName.length) {\n        longer = element.className\n        shorter = commonClassName\n      } else {\n        longer = commonClassName\n        shorter = element.className\n      }\n      shorter.split(' ').forEach((name) => {\n        if (longer.indexOf(name) > -1) {\n          classNames.push(name)\n        }\n      })\n      commonClassName = classNames.join(' ')\n    }\n    // TODO:\n    // - check attributes\n    // if (element.attributes !== commonAttribute) {\n    //\n    // }\n    if (element.tagName !== commonTagName) {\n      commonTagName = null\n    }\n  }\n\n  const selector = getSingleSelector(commonParentNode, options)\n  console.log(selector, commonClassName, commonAttribute, commonTagName)\n\n  if (commonClassName) {\n    return `${selector} > .${commonClassName.replace(/ /g, '.')}`\n  }\n  // if (commonAttribute) {\n  //\n  // }\n  if (commonTagName) {\n    return `${selector} > ${commonTagName.toLowerCase()}`\n  }\n  return `${selector} > *`\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/select.js"],"sourceRoot":""}